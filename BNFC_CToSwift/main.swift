//
//  main.swift
//  BNFC_cToSwift
//
//  Created by Jan Wittler on 04.06.17.
//  Copyright Â© 2017 Jan Wittler. All rights reserved.
//

import Foundation

/// The header placed on top of each source file
private let prefixPlaceholder = "##placeholder##"
private let prefix: String = {
    return "//" + "\n" +
        "//  \(prefixPlaceholder) generated by a custom BNF Converter from Jan Wittler" + "\n" +
        "//" + "\n" +
        "//  This converter assumes files generated with BNFC 2.8.1, GNU Bison 2.3 and Flex 2.5.35" + "\n" +
        "//  Compatibility with other versions can not be guaranteed" + "\n" +
        "//" + "\n" +
    "\n"
}()

/**
 Writes the given file pretty-printed to the given path.
 - parameters:
   - file: The raw string of the file.
   - path: The url where the file should be written.
 - returns: Returns `true` if writing the file succeeded, otherwise `false`.
 */
private func writeFile(_ file: String, to path: URL) -> Bool {
    let output = PrettyPrinter.makePretty(file)
    do {
        try output.write(to: path, atomically: false, encoding: .utf8)
        print("generated file \(path.lastPathComponent)")
        return true
    }
    catch {
        print("writing file at path \(path.absoluteString) failed")
        return false
    }
}

private func printUsageFunction() {
    let usage = "Usage: inputFile [options]" + "\n" +
    "-o : Path to the output directory" + "\n" +
    "-m : Name of the module in the Xcode project to which the BNFC-generated files belong" + "\n" +
    "-extra-case : Additional cases to add to any generated enum"
    print(usage)
}

let configuration = ConsoleIO.parseCommandLineArguments()
guard let inputFile = configuration.inputFile else {
    print("missing argument")
    printUsageFunction()
    exit(-1)
}
guard let mappingGenerator = MappingGenerator(moduleName: configuration.moduleName) else {
    print("invalid module name")
    exit(-1)
}

do {
    print("parsing...")
    
    let rules = try BNFCRule.rules(from: inputFile)
    let abstractSyntax = prefix.replacingOccurrences(of: prefixPlaceholder, with: "Swift Abstract Syntax Interface") + AbstractSyntaxGenerator.generateSwift(from: rules, additionalCases: configuration.additionalCases)
    let mapping = prefix.replacingOccurrences(of: prefixPlaceholder, with: "C to Swift Mapping") + mappingGenerator.generateSwift(from: rules)
    
    print("parsing successful\n")
    
    var outputFiles = [("AbstractSyntax.swift", abstractSyntax),
                       ("Parser.swift", mapping)]
    var success = outputFiles.reduce(true) {
        $0 && writeFile($1.1, to: URL(fileURLWithPath: $1.0, relativeTo: configuration.outputPath))
    }
    guard success else {
        print("writing files failed")
        exit(-1)
    }
    print("")
}
catch let BNFCRule.ParsingError.parsingFailed(message) {
    print("parsing failed with message: \(message)")
    exit(-1)
}
catch let error {
    print("parsing failed with error: \(error)")
    exit(-1)
}
