//
//  main.swift
//  BNFC_cToSwift
//
//  Created by Jan Wittler on 04.06.17.
//  Copyright Â© 2017 Jan Wittler. All rights reserved.
//

import Foundation

/// The header placed on top of each source file
private let prefix: String = {
    return "//" + "\n" +
        "//  Swift Abstract Syntax Interface generated by a custom BNF Converter from Jan Wittler" + "\n" +
        "//" + "\n" +
        "//  This converter assumes files generated by GNU Bison 2.3" + "\n" +
        "//  compatibility with other versions can not be guaranteed" + "\n" +
        "//" + "\n" +
    "\n"
}()

/**
 Writes the given file pretty-printed to the given path.
 - parameters:
   - file: The raw string of the file.
   - path: The url where the file should be written.
 - returns: Returns `true` if writing the file succeeded, otherwise `false`.
 */
private func writeFile(_ file: String, to path: URL) -> Bool {
    let output = PrettyPrinter.makePretty(file)
    do {
        try output.write(to: path, atomically: false, encoding: .utf8)
        print("generated file \(path.lastPathComponent)")
        return true
    }
    catch {
        print("writing file at path \(path.absoluteString) failed")
        return false
    }
}

let configuration = ConsoleIO.parseCommandLineArguments()
guard let inputFile = configuration.inputFile else {
    print("missing argument")
    exit(-1)
    //TODO: usage function
}
guard let mappingGenerator = MappingGenerator(moduleName: configuration.moduleName) else {
    print("invalid module name")
    exit(-1)
}

do {
    print("parsing...")
    
    let rules = try BNFCRule.rules(from: inputFile)
    let abstractSyntax = prefix + AbstractSyntaxGenerator.generateSwift(from: rules)
    let mapping = prefix + mappingGenerator.generateSwift(from: rules)
    
    print("parsing successful\n")
    
    var outputFiles = [("AbstractSyntax.swift", abstractSyntax),
                       ("Parser.swift", mapping)]
    var success = outputFiles.reduce(true) {
        $0 && writeFile($1.1, to: URL(fileURLWithPath: $1.0, relativeTo: configuration.outputPath))
    }
    guard success else {
        print("writing files failed")
        exit(-1)
    }
    print("")
}
catch let BNFCRule.ParsingError.parsingFailed(message) {
    print("parsing failed with message: \(message)")
    exit(-1)
}
catch let error {
    print("parsing failed with error: \(error)")
    exit(-1)
}
